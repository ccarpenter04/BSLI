package com.carpenter.bytecode;

import com.carpenter.bytecode.hierachy.BytecodeClass;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.tree.AnnotationNode;
import org.objectweb.asm.tree.ClassNode;

import java.util.List;

/**
 * An enum containing the languages that can currently be identified or are planned to be identified.
 *
 * @author Christopher Carpenter
 */
public enum SourceLanguage {
    JAVA("https://www.java.com"),
    SCALA("http://www.scala-lang.org"),
    GROOVY("http://www.groovy-lang.org"),
    KOTLIN("https://kotlinlang.org", "Sponsored and developed by JetBrains"),
    CEYLON("http://www.ceylon-lang.org", "Sponsored by Red Hat"),
    //TODO add identification to BytecodeClass#getSourceLanguage
    CLOJURE("http://clojure.org"),
    JRUBY("http://jruby.org"),
    JYTHON("http://www.jython.org"),
    //TODO discover other notable languages
    UNKNOWN;
    private final String[] notes;

    SourceLanguage() {
        this((String[]) null);
    }

    SourceLanguage(String... notes) {
        this.notes = notes;
    }

    /**
     * Gets the source language of the provided BytecodeClass.
     * This isn't always accurate but is good enough to make a reasonable assumption.
     * For example, if the sourceFile attribute has been removed then there is no way to distinguish
     * a groovy annotation from a java annotation. This also applies to groovy interfaces and java interfaces.
     */
    public static SourceLanguage identify(BytecodeClass bc) {
        ClassNode asm = bc.asm();
        if (asm.sourceFile != null) {
            //These could be faked but it's more likely that they would be removed instead.
            if (asm.sourceFile.endsWith(".java")) {
                return SourceLanguage.JAVA;
            } else if (asm.sourceFile.endsWith(".scala")) {
                return SourceLanguage.SCALA;
            } else if (asm.sourceFile.endsWith(".groovy")) {
                return SourceLanguage.GROOVY;
            } else if (asm.sourceFile.endsWith(".kt")) {
                return SourceLanguage.KOTLIN;
            } else if (asm.sourceFile.endsWith(".ceylon")) {
                return SourceLanguage.CEYLON;
            } else {
                //We could run it through the rest of the identification techniques, but should we?
                return SourceLanguage.UNKNOWN;
            }
        } else {
            /*
            * TODO add detection of when an enum was generated by Groovy.
            * Groovy adds several additional methods to it's enums along with Adding Lgroovy/lang/GroovyObject;
            * to it's class signature (but the latter may not be reliable because signatures can be erased without
            * causing issues when running bytecode.
            */
            if (asm.superName.equals("groovy/lang/Script")) {
                //Top level Groovy classes extend this.

                //There may need more work done here to make it more accurate however
                //I'm not fluent enough in Groovy to confirm that.

                //If anyone would like to write a relatively complex groovy project and provide me with both the
                //source and generated bytecode so I could investigate it would be appreciated.
                return SourceLanguage.GROOVY;
            }
            for (String iface : (List<String>) asm.interfaces) {
                if (iface.equals("groovy/lang/GroovyObject")) {
                    //All inner Groovy classes implement this.
                    return SourceLanguage.GROOVY;
                }
            }
            if (asm.visibleAnnotations != null) {
                for (AnnotationNode annotation : (List<AnnotationNode>) asm.visibleAnnotations) {
                    switch (annotation.desc) {
                        case "Lkotlin/jvm/internal/KotlinClass;":
                            //Kotlin classes, enums, ojects, and interfaces have this annotation.
                            //It contains information about the primary constructor among other things
                            return SourceLanguage.KOTLIN;
                        case "Lscala/reflect/ScalaSignature;":
                            //Scala classes, objects, and traits have this annotation.
                            //It contains information that Scala uses for reflection.
                            return SourceLanguage.SCALA;
                        case "Lgroovy/transform/Trait;":
                            //Top level groovy traits contain this annotation.
                            //If it contains any useful information, please inform me.
                            return SourceLanguage.GROOVY;
                        case "Lcom/redhat/ceylon/compiler/java/metadata/Ceylon;":
                            //All classes generated by Ceylon contain this annotation
                            return SourceLanguage.CEYLON;
                    }
                }
            }
            if (asm.attrs != null) {
                for (Attribute attribute : (List<Attribute>) asm.attrs) {
                    switch (attribute.type) {
                        case "Scala":
                            //Scala "inner" objects and traits contain this non-standard bytecode attribute.
                            //By "inner" objects and traits I'm referring to the class that ends with $ that's
                            //generated when you compile a Scala object or trait.
                            //I'm not sure of it's purpose and would like someone to explain it to me.
                            return SourceLanguage.SCALA;
                        case "ScalaSig":
                            //Scala classes, objects, and traits contain this non-standard bytecode attribute.
                            //I'm not sure of it's purpose and would like someone to explain it to me.
                            return SourceLanguage.SCALA;
                        case "ScalaInlineInfo":
                            //Scala classes and traits contain this non-standard bytecode attribute.
                            //Scala "inner" objects also contain this non-standard bytecode attribute.
                            //By "inner" objects I'm referring to the class that ends with $ that's generated
                            //when you compile a Scala object.
                            //I'm not sure of it's purpose and would like someone to explain it to me.
                            return SourceLanguage.SCALA;
                    }
                }
            }
            //Let's assume java if we don't think it's any other supported language.
            return SourceLanguage.JAVA;
        }
    }
}

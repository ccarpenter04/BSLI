package com.carpenter.bytecode;

import com.carpenter.bytecode.hierachy.BytecodeClass;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.tree.AnnotationNode;
import org.objectweb.asm.tree.ClassNode;

import java.util.Arrays;
import java.util.List;

/**
 * An enum containing the languages that we try to detect as the source language of bytecode classes.
 *
 * @author Christopher Carpenter
 */
public enum SourceCodeLanguage {
    JAVA("https://www.java.com"),
    SCALA("http://www.scala-lang.org"),
    GROOVY("http://www.groovy-lang.org"),
    KOTLIN("https://kotlinlang.org", "Sponsored and developed by JetBrains"),
    CEYLON("http://www.ceylon-lang.org", "Sponsored by Red Hat");
    private final String[] notes;

    SourceCodeLanguage(String... notes) {
        this.notes = notes;
    }

    @Override
    public String toString() {
        return name() + " " + Arrays.asList(notes);
    }

    /**
     * Gets the source code language of the provided BytecodeClass.
     * This is only accurate when the sourceFile attribute has not been spoofed in any way.
     * If the sourceFile attribute has been completely removed, then the source code language is identified via markers that the source code language's compilers leave behind in the bytecode.
     * Unfortunately, not all compilers leave behind markers that can be used to identify the bytecode's source code language.
     * For example, if the sourceFile attribute has been removed from a Groovy annotation then we are unable to detect that it was originally s Groovy annotation and will instead report back that it's source code language was Java.
     * Without the sourceFile attribute, Groovy interfaces can also not be distinguished from Java interfaces.
     *
     * @param bc An instance of a BytecodeClass
     * @return A SourceCodeLanguage object that represents the source code language that we determined a given BytecodeClass was compiled from.
     */
    public static SourceCodeLanguage identify(BytecodeClass bc) {
        ClassNode asm = bc.asm();
        if (asm.sourceFile != null) {
            /*
            These can be used to accurately determine the source code language when
            1) The sourceFile attribute was not manipulated by an obfuscater.
            2) The source code language isn't translated into another source code language before being compiled into bytecode.

            For an example of a language that violates condition #2, please take a look at the Xtend project hosted by eclipse.
             */
            if (asm.sourceFile.endsWith(".java")) {
                return SourceCodeLanguage.JAVA;
            } else if (asm.sourceFile.endsWith(".scala")) {
                return SourceCodeLanguage.SCALA;
            } else if (asm.sourceFile.endsWith(".groovy")) {
                return SourceCodeLanguage.GROOVY;
            } else if (asm.sourceFile.endsWith(".kt")) {
                return SourceCodeLanguage.KOTLIN;
            } else if (asm.sourceFile.endsWith(".ceylon")) {
                return SourceCodeLanguage.CEYLON;
            }
        }
        /*
         * TODO add detection of when an enum was generated by Groovy.
         * Groovy adds several additional methods to it's enums along with Adding Lgroovy/lang/GroovyObject;
         * to it's class signature (but the latter may not be reliable because signatures can be erased without
         * causing issues when running bytecode.
         */
        if (asm.superName.equals("groovy/lang/Script")) {
            //Top level Groovy classes extend groovy/lang/Script.

            /*
             * There may need more work done here to make it more accurate however
             * I'm not fluent enough in Groovy to confirm that.
             *
             * If anyone would like to write a relatively complex groovy project and provide me with both the
             * source and generated bytecode so I could investigate the issue, it would be appreciated.
             */

            return SourceCodeLanguage.GROOVY;
        }
        for (String iface : (List<String>) asm.interfaces) {
            if (iface.equals("groovy/lang/GroovyObject")) {
                //All inner Groovy classes implement this.
                return SourceCodeLanguage.GROOVY;
            }
        }
        if (asm.visibleAnnotations != null) {
            for (AnnotationNode annotation : (List<AnnotationNode>) asm.visibleAnnotations) {
                switch (annotation.desc) {
                    case "Lkotlin/jvm/internal/KotlinClass;":
                        //Kotlin classes, enums, ojects, and interfaces have this annotation.
                        //It contains information about the primary constructor among other things
                        return SourceCodeLanguage.KOTLIN;
                    case "Lscala/reflect/ScalaSignature;":
                        //Scala classes, objects, and traits have this annotation.
                        //It contains information that Scala uses for reflection.
                        return SourceCodeLanguage.SCALA;
                    case "Lgroovy/transform/Trait;":
                        //Top level groovy traits contain this annotation.
                        //If it contains any useful information, please inform me.
                        return SourceCodeLanguage.GROOVY;
                    case "Lcom/redhat/ceylon/compiler/java/metadata/Ceylon;":
                        //All classes generated by Ceylon contain this annotation
                        return SourceCodeLanguage.CEYLON;
                }
            }
        }
        if (asm.attrs != null) {
            for (Attribute attribute : (List<Attribute>) asm.attrs) {
                switch (attribute.type) {
                    case "Scala":
                        //Scala "inner" objects and traits contain this non-standard bytecode attribute.
                        //By "inner" objects and traits I'm referring to the class that ends with $ that's
                        //generated when you compile a Scala object or trait.
                        //I'm not sure of it's purpose and would be welcome to having someone explain it to me.
                        return SourceCodeLanguage.SCALA;
                    case "ScalaSig":
                        //Scala classes, objects, and traits contain this non-standard bytecode attribute.
                        //I'm not sure of it's purpose and would be welcome to having someone explain it to me.
                        return SourceCodeLanguage.SCALA;
                    case "ScalaInlineInfo":
                        //Scala classes and traits contain this non-standard bytecode attribute.
                        //Scala "inner" objects also contain this non-standard bytecode attribute.
                        //By "inner" objects I'm referring to the class that ends with $ that's generated
                        //when you compile a Scala object.
                        //I'm not sure of it's purpose and would be welcome to having someone explain it to me.
                        return SourceCodeLanguage.SCALA;
                }
            }
        }
        /*
        Let's assume that the source code language was Java if we don't identify a marker that would lead us to believe
        that it's bytecode was built from another source code language.
        */
        return SourceCodeLanguage.JAVA;
    }
}

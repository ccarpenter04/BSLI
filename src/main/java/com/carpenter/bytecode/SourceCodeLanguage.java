package com.carpenter.bytecode;

import com.carpenter.bytecode.hierachy.BytecodeClass;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.tree.*;

import java.util.Arrays;
import java.util.ListIterator;

/**
 * An enum containing the languages that we try to detect as the source language of bytecode classes.
 *
 * @author Christopher Carpenter
 */
public enum SourceCodeLanguage {
    JAVA("https://www.java.com"),
    SCALA("http://www.scala-lang.org"),
    GROOVY("http://www.groovy-lang.org", "Supported by the Apache Software Foundation"),
    KOTLIN("https://kotlinlang.org", "Sponsored and developed by JetBrains"),
    CEYLON("http://www.ceylon-lang.org", "Sponsored by Red Hat");
    private final String[] notes;

    SourceCodeLanguage(String... notes) {
        this.notes = notes;
    }

    /**
     * Gets the source code language of the provided BytecodeClass using the sourceFile attribute when available.
     * Otherwise markers left behind by the source code language's compiler are used.
     *
     * @param bclass An non-null instance of a BytecodeClass
     * @return A non-null SourceCodeLanguage value
     */
    public static SourceCodeLanguage identify(BytecodeClass bclass) {
        return identify(bclass, true);
    }

    /**
     * Gets the source code language of the provided BytecodeClass.
     * <p>
     * If useSrcAttribute is set to true, then the sourceFile attribute is used if it's available. Otherwise the
     * source code language is identified by markers left by its compiler.
     * <p>
     * Unfortunately, not all compilers leave behind markers that can be used to identify the source code language.
     * <p>
     * Some notable examples of bytecode without any anticipated markers are groovy annotations, groovy interfaces.
     *
     * @param bclass          A non-null instance of a BytecodeClass
     * @param useSrcAttribute Whether we should use the source file attribute if available
     * @return A non-null SourceCodeLanguage value
     */
    public static SourceCodeLanguage identify(BytecodeClass bclass, boolean useSrcAttribute) {
        ClassNode asm = bclass.asm();
        if (useSrcAttribute && asm.sourceFile != null) {
            /*
            These can be used to accurately determine the source code language when:
            1) The sourceFile attribute was not manipulated by an obfuscater.
            2) The source code isn't precomputed into another language before being compiled into bytecode.

            For an example of a language that violates condition #2, take a look at Xtend (hosted by eclipse).
             */
            if (asm.sourceFile.endsWith(".java")) {
                return SourceCodeLanguage.JAVA;
            } else if (asm.sourceFile.endsWith(".scala")) {
                return SourceCodeLanguage.SCALA;
            } else if (asm.sourceFile.endsWith(".groovy")) {
                return SourceCodeLanguage.GROOVY;
            } else if (asm.sourceFile.endsWith(".kt")) {
                return SourceCodeLanguage.KOTLIN;
            } else if (asm.sourceFile.endsWith(".ceylon")) {
                return SourceCodeLanguage.CEYLON;
            }
        }
        if (asm.superName.equals("groovy/lang/Script")) {
            //Top level Groovy classes extend groovy/lang/Script.
            return SourceCodeLanguage.GROOVY;
        }
        for (String iface : asm.interfaces) {
            if (iface.equals("groovy/lang/GroovyObject")) {
                //Groovy enums and inner classes implement groovy/lang/GroovyObject.
                return SourceCodeLanguage.GROOVY;
            }
        }
        if (asm.visibleAnnotations != null) {
            for (AnnotationNode annotation : asm.visibleAnnotations) {
                switch (annotation.desc) {
                    case "Lkotlin/jvm/internal/KotlinClass;":
                        //Kotlin classes, enums, objects, and interfaces have this annotation.
                        //It contains information about the primary constructor among other things
                        return SourceCodeLanguage.KOTLIN;
                    case "Lscala/reflect/ScalaSignature;":
                        //Scala classes, objects, and traits have this annotation.
                        //It contains information that Scala uses for reflection.
                        return SourceCodeLanguage.SCALA;
                    case "Lgroovy/transform/Trait;":
                        //Top level groovy traits contain this annotation.
                        //If it contains any useful information, please inform me.
                        return SourceCodeLanguage.GROOVY;
                    case "Lcom/redhat/ceylon/compiler/java/metadata/Ceylon;":
                        //All classes generated by Ceylon contain this annotation
                        return SourceCodeLanguage.CEYLON;
                }
            }
        }
        if (asm.attrs != null) {
            for (Attribute attribute : asm.attrs) {
                switch (attribute.type) {
                    case "Scala":
                        //Scala "inner" objects and traits contain this non-standard bytecode attribute.
                        //By "inner" objects and traits I'm referring to the class that ends with $ that's
                        //generated when you compile a Scala object or trait.
                        //I'm not sure of it's purpose and would be welcome to having someone explain it to me.
                        return SourceCodeLanguage.SCALA;
                    case "ScalaSig":
                        //Scala classes, objects, and traits contain this non-standard bytecode attribute.
                        //I'm not sure of it's purpose and would be welcome to having someone explain it to me.
                        return SourceCodeLanguage.SCALA;
                    case "ScalaInlineInfo":
                        //Scala classes and traits contain this non-standard bytecode attribute.
                        //Scala "inner" objects also contain this non-standard bytecode attribute.
                        //By "inner" objects I'm referring to the class that ends with $ that's generated
                        //when you compile a Scala object.
                        //I'm not sure of it's purpose and would be welcome to having someone explain it to me.
                        return SourceCodeLanguage.SCALA;
                }
            }
        }
        for (MethodNode mn : asm.methods) {
            ListIterator<AbstractInsnNode> itr = mn.instructions.iterator();
            while (itr.hasNext()) {
                AbstractInsnNode insn = itr.next();
                //Look for kotlin standard library calls.
                if (insn instanceof MethodInsnNode && ((MethodInsnNode) insn).owner.startsWith("kotlin/")) {
                    return SourceCodeLanguage.KOTLIN;
                }
            }
        }
        /*
        Let's assume that the source code language was Java if we don't identify a marker that would lead us to believe
        that the bytecode was built from another source code language.
        */
        return SourceCodeLanguage.JAVA;
    }

    @Override
    public String toString() {
        return name() + ' ' + Arrays.asList(notes);
    }
}

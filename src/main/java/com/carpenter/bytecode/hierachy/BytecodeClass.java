package com.carpenter.bytecode.hierachy;

import com.carpenter.bytecode.SourceLanguage;
import org.objectweb.asm.Attribute;
import org.objectweb.asm.Opcodes;
import org.objectweb.asm.tree.AnnotationNode;
import org.objectweb.asm.tree.ClassNode;

import java.util.List;

/**
 * A simple wrapper around asm's ClassNode object
 *
 * @author Christopher Carpenter
 */
public class BytecodeClass {
    private final ClassNode asm;
    private SourceLanguage language;

    public BytecodeClass(ClassNode asm) {
        this.asm = asm;
    }

    public ClassNode asm() {
        return asm;
    }

    public boolean isPublic() {
        return (asm.access & Opcodes.ACC_PUBLIC) == Opcodes.ACC_PUBLIC;
    }

    public boolean isProtected() {
        return (asm.access & Opcodes.ACC_PROTECTED) == Opcodes.ACC_PROTECTED;
    }

    public boolean isPrivate() {
        return (asm.access & Opcodes.ACC_PRIVATE) == Opcodes.ACC_PRIVATE;
    }

    public boolean isPackageLocal() {
        return !isPublic() && !isProtected() && !isPrivate();
    }

    public boolean isEnum() {
        return (asm.access & Opcodes.ACC_ENUM) == Opcodes.ACC_ENUM;
    }

    public boolean isInterface() {
        return (asm.access & Opcodes.ACC_INTERFACE) == Opcodes.ACC_INTERFACE;
    }

    public boolean isAnnotation() {
        return (asm.access & Opcodes.ACC_ANNOTATION) == Opcodes.ACC_ANNOTATION;
    }

    public boolean isFinal() {
        return (asm.access & Opcodes.ACC_FINAL) == Opcodes.ACC_FINAL;
    }

    public boolean isAbstract() {
        return (asm.access & Opcodes.ACC_ABSTRACT) == Opcodes.ACC_ABSTRACT;
    }

    /**
     * Gets if the class is static. Used exclusively for inner classes.
     */
    public boolean isStatic() {
        return (asm.access & Opcodes.ACC_STATIC) == Opcodes.ACC_STATIC;
    }

    public boolean isSynthetic() {
        return (asm.access & Opcodes.ACC_SYNTHETIC) == Opcodes.ACC_SYNTHETIC;
    }

    /**
     * "Treat superclass methods specially when invoked by the invokespecial instruction."
     * https://docs.oracle.com/javase/specs/jvms/se7/html/jvms-6.html#jvms-6.5.invokespecial
     * <p>
     * "In Java SE 8 and above, the Java Virtual Machine considers the ACC_SUPER flag to be set in every class file,
     * regardless of the actual value of the flag in the class file and the version of the class file."
     * https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-4.html#jvms-4.1-200-E.1
     */
    public boolean hasSuperFlag() {
        return (asm.access & Opcodes.ACC_SUPER) == Opcodes.ACC_SUPER;
    }

    /**
     * Gets the source language of the bytecode class.
     * This isn't always accurate but is give enough to make a reasonable assumption.
     * For example, if the sourceFile attribute has been removed then there is no way to distinguish
     * a groovy annotation from a java annotation. This also applies to groovy interfaces and java interfaces.
     */
    public SourceLanguage getSourceLanguage() {
        if (language == null) {
            if (asm.sourceFile != null) {
                //These could be faked but it's more likely that they would just be removed.
                if (asm.sourceFile.endsWith(".java")) {
                    language = SourceLanguage.JAVA;
                } else if (asm.sourceFile.endsWith(".scala")) {
                    language = SourceLanguage.SCALA;
                } else if (asm.sourceFile.endsWith(".groovy")) {
                    language = SourceLanguage.GROOVY;
                } else if (asm.sourceFile.endsWith(".kt")) {
                    language = SourceLanguage.KOTLIN;
                } else {
                    language = SourceLanguage.UNKNOWN;
                }
            } else {
                /*
                 * TODO add detection of when an enum was generated by Groovy.
                 * Groovy adds several additional methods to it's enums along with Adding Lgroovy/lang/GroovyObject;
                 * to it's class signature (but the latter may not be reliable because signatures can be erased without
                 * causing issues when running bytecode.
                 */
                //Let's assume java unless we can find a reason to believe otherwise.
                language = SourceLanguage.JAVA;
                if (asm.superName.equals("groovy/lang/Script")) {
                    //Top level Groovy classes extend this.

                    //There may need more work done here to make it more accurate however
                    //I'm not fluent enough in Groovy to confirm that.

                    //If anyone would like to write a relatively complex groovy project and provide me with both the
                    //source and generated bytecode so I could investigate it would be appreciated.
                    language = SourceLanguage.GROOVY;
                }
                for (String iface : (List<String>) asm.interfaces) {
                    if (iface.equals("groovy/lang/GroovyObject")) {
                        //All inner Groovy classes implement this.
                        language = SourceLanguage.GROOVY;
                    }
                }
                if (asm.visibleAnnotations != null) {
                    for (AnnotationNode annotation : (List<AnnotationNode>) asm.visibleAnnotations) {
                        switch (annotation.desc) {
                            case "Lkotlin/jvm/internal/KotlinClass;":
                                //Kotlin classes, enums, ojects, and interfaces have this annotation.
                                //It contains information about the primary constructor among other things
                                language = SourceLanguage.KOTLIN;
                                break;
                            case "Lscala/reflect/ScalaSignature;":
                                //Scala classes, objects, and traits have this annotation.
                                //It contains information that Scala uses for reflection.
                                language = SourceLanguage.SCALA;
                                break;
                            case "Lgroovy/transform/Trait;":
                                //Top level groovy traits contain this annotation.
                                //If it contains any useful information, please inform me.
                                language = SourceLanguage.GROOVY;
                                break;
                        }
                    }
                }
                if (asm.attrs != null) {
                    for (Attribute attribute : (List<Attribute>) asm.attrs) {
                        switch (attribute.type) {
                            case "Scala":
                                //Scala "inner" objects and traits contain this non-standard bytecode attribute.
                                //By "inner" objects and traits I'm referring to the class that ends with $ that's
                                //generated when you compile a Scala object or trait.
                                //I'm not sure of it's purpose and would like someone to explain it to me.
                                language = SourceLanguage.SCALA;
                                break;
                            case "ScalaSig":
                                //Scala classes, objects, and traits contain this non-standard bytecode attribute.
                                //I'm not sure of it's purpose and would like someone to explain it to me.
                                language = SourceLanguage.SCALA;
                                break;
                            case "ScalaInlineInfo":
                                //Scala classes and traits contain this non-standard bytecode attribute.
                                //Scala "inner" objects also contain this non-standard bytecode attribute.
                                //By "inner" objects I'm referring to the class that ends with $ that's generated
                                //when you compile a Scala object.
                                //I'm not sure of it's purpose and would like someone to explain it to me.
                                language = SourceLanguage.SCALA;
                                break;
                        }
                    }
                }
            }
        }
        return language;
    }
}
